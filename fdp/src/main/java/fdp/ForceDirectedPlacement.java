package fdp;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.stream.IntStream;

import org.jgrapht.Graph;

import fdp.graph.Edge;
import fdp.graph.Vertex;
import javafx.scene.chart.XYChart.Data;
import parsii.tokenizer.ParseException;

public class ForceDirectedPlacement {

	/**
	 * Simulates the force-directed placement layout algorithm in a new Thread.
	 * 
	 * @param graph the graph to layout
	 * @param parameter parameters for the simulation
	 * @throws ParseException when the Strings in parameter that represent the force functions are malformed or empty
	 */
	public static void simulate(Graph<Vertex, Edge> graph, Parameter parameter) throws ParseException {
		Executors.newSingleThreadExecutor().submit(new Simulation(graph, parameter));
	}
	
	/**
	 * Tries to find optimal cooling rates for the Graph generated by the given GraphGenerator and the given forces.
	 * 
	 * @param config the GraphGenerator and parameters as GraphConfiguration object
	 * @param from initial cooling rate, must be greater 0 and less than 1.
	 * @param to maximum cooling rate, must be greater 0 and less than 1.
	 * @param stepSize currently tested cooling rate is increased by stepSize every step, must be greater 0.
	 * @param sampleSize for every cooling rate tested, sampleSize samples are taken and the average iterations used is calculated from them
	 * @return a list of XYChart.Data objects, containing a mapping between cooling rate and iterations
	 * @throws ParseException
	 */
	public static List<Data<Double, Integer>> optimizeCoolingRate(GraphConfiguration config, double from, double to, double stepSize, int sampleSize) throws ParseException {
		
		Parameter p = config.getParameter();
		List<Data<Double, Integer>> chartValues = new ArrayList<>();
		ExecutorService exec = Executors.newFixedThreadPool(sampleSize);
		List<Future<Integer>> currResults = new ArrayList<>();
		config.getParameter().setEquilibriumCriterion(true);
		p.setFrameDelay(0);
		
		// need sampleSize objects of the same graph, because we will simulate them in parallel
		List<Graph<Vertex, Edge>> graphs = new ArrayList<>();
		IntStream.range(0, sampleSize).forEach(i -> graphs.add(config.generateGraph()));
		
		// for every cooling rate to test, simulate sampleSize graph layouts in parallel, retrieve the iterations used until equilibrium,
		// and calculate the average number of iterations for that cooling rate
		for (double currentCoolingRate = from; currentCoolingRate <= to; currentCoolingRate += stepSize) {
			int iterationsUsed = 0;
			p.setCoolingRate(currentCoolingRate);
			for (int i = 0; i < sampleSize; i++) {
				currResults.add(exec.submit(new Simulation(graphs.get(i), p)));
			}
			// collect the results, i.e. wait for all threads to finish
			for (Future<Integer> result : currResults) {
				try {
					iterationsUsed += result.get();
				} catch (InterruptedException | ExecutionException e) {
					e.printStackTrace();
				}
			}
			// get average and save the result
			iterationsUsed /= sampleSize;
			chartValues.add(new Data<>(currentCoolingRate, iterationsUsed));
			
			currResults.clear();
		}
		
		return chartValues;
	}
}
